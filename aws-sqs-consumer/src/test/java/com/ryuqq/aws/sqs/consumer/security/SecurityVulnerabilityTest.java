package com.ryuqq.aws.sqs.consumer.security;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.ryuqq.aws.sqs.consumer.container.SqsListenerContainer;
import com.ryuqq.aws.sqs.consumer.container.ContainerState;
import com.ryuqq.aws.sqs.consumer.registry.SqsListenerContainerRegistry;
import com.ryuqq.aws.sqs.consumer.types.DlqMessage;
import com.ryuqq.aws.sqs.service.SqsService;
import com.ryuqq.aws.sqs.types.SqsMessage;
import com.ryuqq.aws.sqs.consumer.annotation.SqsListener;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.springframework.context.ApplicationContext;
import org.springframework.core.env.Environment;

import java.lang.reflect.Method;
import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

/**
 * Security vulnerability tests to validate fixes for:
 * 1. JSON Injection in DLQ handling
 * 2. Concurrent modification in registry operations
 * 3. Thread safety issues in state management
 */
class SecurityVulnerabilityTest {
    
    private SqsService mockSqsService;
    private Environment mockEnvironment;
    private ApplicationContext mockApplicationContext;
    private ExecutorService executorService;
    private ObjectMapper objectMapper;
    
    @BeforeEach
    void setUp() {
        mockSqsService = mock(SqsService.class);
        mockEnvironment = mock(Environment.class);
        mockApplicationContext = mock(ApplicationContext.class);
        executorService = Executors.newFixedThreadPool(4);
        objectMapper = new ObjectMapper();
    }
    
    @Test
    @DisplayName("JSON Injection vulnerability should be prevented in DLQ handling")
    void testJsonInjectionPrevention() throws Exception {
        // Arrange: Create malicious payload that would cause injection in old string concatenation approach
        String maliciousPayload = "{\"legitimate\":\"data\",\"injection\":\"\\\",\\\"maliciousField\\\":\\\"injectedValue\\\",\\\"timestamp\\\":\\\"";
        String maliciousError = "Error occurred\",\"injectedError\":\"malicious\",\"fake\":\"";
        
        SqsMessage maliciousMessage = SqsMessage.builder()
            .messageId("test-id")
            .body(maliciousPayload)
            .receiptHandle("test-handle")
            .attributes(Map.of("ApproximateReceiveCount", "1"))
            .build();
        
        Exception maliciousException = new RuntimeException(maliciousError);
        
        // Create DlqMessage using the secure builder pattern
        DlqMessage dlqMessage = DlqMessage.builder()
            .originalMessageId(maliciousMessage.getMessageId())
            .originalMessage(maliciousMessage.getBody())
            .errorMessage(maliciousException.getMessage())
            .errorType(maliciousException.getClass().getSimpleName())
            .timestamp(Instant.now())
            .containerId("test-container")
            .queueUrl("https://test-queue")
            .retryAttempts(3)
            .originalAttributes(maliciousMessage.getAttributes())
            .build();
        
        // Act: Serialize to JSON using secure ObjectMapper
        String serializedJson = objectMapper.writeValueAsString(dlqMessage);
        
        // Assert: Verify JSON is properly escaped and structured
        JsonNode jsonNode = objectMapper.readTree(serializedJson);
        
        // Verify structure integrity
        assertTrue(jsonNode.has("originalMessage"));
        assertTrue(jsonNode.has("errorMessage"));
        assertTrue(jsonNode.has("timestamp"));
        assertTrue(jsonNode.has("containerId"));
        
        // Verify malicious content is properly escaped
        assertEquals(maliciousPayload, jsonNode.get("originalMessage").asText());
        assertEquals(maliciousError, jsonNode.get("errorMessage").asText());
        assertEquals("test-container", jsonNode.get("containerId").asText());
        
        // Verify no injection occurred - JSON should be valid and well-formed
        assertDoesNotThrow(() -> objectMapper.readTree(serializedJson));
        
        // Verify specific fields that could be injection targets are properly isolated
        assertFalse(serializedJson.contains("\"injectedError\":\"malicious\""));
        assertFalse(serializedJson.contains("\"maliciousField\":\"injectedValue\""));
    }
    
    @Test
    @DisplayName("Container state transitions should be thread-safe")
    void testContainerStateThreadSafety() throws Exception {
        // Arrange
        SqsListenerContainer container = createTestContainer();
        int threadCount = 10;
        int operationsPerThread = 100;
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch completionLatch = new CountDownLatch(threadCount);
        AtomicInteger successfulStarts = new AtomicInteger(0);
        AtomicInteger successfulStops = new AtomicInteger(0);
        
        // Setup mock responses
        when(mockSqsService.getQueueUrl(anyString())).thenReturn(CompletableFuture.completedFuture("https://test-queue"));
        when(mockEnvironment.resolvePlaceholders(anyString())).thenReturn("test-queue");
        
        // Act: Multiple threads attempting concurrent start/stop operations
        for (int i = 0; i < threadCount; i++) {
            executorService.submit(() -> {
                try {
                    startLatch.await();
                    
                    for (int op = 0; op < operationsPerThread; op++) {
                        try {
                            container.start();
                            if (container.getState() == ContainerState.RUNNING) {
                                successfulStarts.incrementAndGet();
                            }
                            
                            Thread.sleep(1); // Brief pause
                            
                            container.stop();
                            if (container.getState() == ContainerState.STOPPED) {
                                successfulStops.incrementAndGet();
                            }
                            
                        } catch (Exception e) {
                            // Expected some operations to fail due to invalid state transitions
                        }
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    completionLatch.countDown();
                }
            });
        }
        
        // Start all threads simultaneously
        startLatch.countDown();
        
        // Wait for completion with timeout
        assertTrue(completionLatch.await(30, TimeUnit.SECONDS), "Operations should complete within timeout");
        
        // Assert: Verify container is in a valid final state
        ContainerState finalState = container.getState();
        assertTrue(finalState == ContainerState.STOPPED || finalState == ContainerState.FAILED,
            "Container should be in STOPPED or FAILED state, but was: " + finalState);
        
        // Verify that state transitions were controlled
        assertTrue(successfulStarts.get() > 0, "Some start operations should have succeeded");
        assertTrue(successfulStops.get() > 0, "Some stop operations should have succeeded");
        
        // Verify no invalid state combinations exist
        assertFalse(container.isRunning() && (finalState == ContainerState.STOPPED || finalState == ContainerState.FAILED),
            "Container state should be consistent with isRunning()");
    }
    
    @Test
    @DisplayName("Registry concurrent operations should be thread-safe")
    void testRegistryConcurrentOperations() throws Exception {
        // Arrange
        SqsListenerContainerRegistry registry = new SqsListenerContainerRegistry();
        int threadCount = 20;
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch completionLatch = new CountDownLatch(threadCount);
        AtomicInteger registrationCount = new AtomicInteger(0);
        AtomicInteger unregistrationCount = new AtomicInteger(0);
        
        // Act: Concurrent registration/unregistration operations
        for (int i = 0; i < threadCount; i++) {
            final int threadIndex = i;
            executorService.submit(() -> {
                try {
                    startLatch.await();
                    
                    // Register containers
                    for (int j = 0; j < 10; j++) {
                        String containerId = "container-" + threadIndex + "-" + j;
                        try {
                            SqsListenerContainer container = createTestContainer();
                            registry.registerContainer(containerId, container);
                            registrationCount.incrementAndGet();
                            
                            // Immediately unregister some containers
                            if (j % 2 == 0) {
                                registry.unregisterContainer(containerId);
                                unregistrationCount.incrementAndGet();
                            }
                        } catch (Exception e) {
                            // Some operations may fail due to concurrent modifications
                        }
                    }
                    
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    completionLatch.countDown();
                }
            });
        }
        
        // Start all threads
        startLatch.countDown();
        
        // Wait for completion
        assertTrue(completionLatch.await(30, TimeUnit.SECONDS), "Registry operations should complete within timeout");
        
        // Assert: Verify registry integrity
        assertNotNull(registry.getAllContainers(), "getAllContainers() should not return null");
        
        // Verify stats can be computed without concurrent modification exceptions
        assertDoesNotThrow(() -> {
            SqsListenerContainerRegistry.RegistryStats stats = registry.getStats();
            assertNotNull(stats);
            assertTrue(stats.getTotalContainers() >= 0);
        });
        
        // Verify concurrent start/stop operations work
        assertDoesNotThrow(() -> {
            CompletableFuture<Void> startFuture = CompletableFuture.runAsync(() -> registry.start());
            CompletableFuture<Void> stopFuture = CompletableFuture.runAsync(() -> registry.stop());
            
            CompletableFuture.allOf(startFuture, stopFuture).get(10, TimeUnit.SECONDS);
        });
        
        assertTrue(registrationCount.get() > 0, "Some registrations should have succeeded");
    }
    
    @Test
    @DisplayName("DLQ message serialization should handle edge cases securely")
    void testDlqMessageSerializationEdgeCases() throws Exception {
        // Test various edge cases that could cause security issues
        
        // Null values
        DlqMessage nullMessage = DlqMessage.builder()
            .originalMessageId(null)
            .originalMessage(null)
            .errorMessage(null)
            .errorType(null)
            .containerId("test")
            .build();
        
        String serialized = objectMapper.writeValueAsString(nullMessage);
        JsonNode jsonNode = objectMapper.readTree(serialized);
        assertTrue(jsonNode.get("originalMessageId").isNull());
        
        // Empty strings
        DlqMessage emptyMessage = DlqMessage.builder()
            .originalMessageId("")
            .originalMessage("")
            .errorMessage("")
            .errorType("")
            .containerId("test")
            .build();
        
        serialized = objectMapper.writeValueAsString(emptyMessage);
        jsonNode = objectMapper.readTree(serialized);
        assertEquals("", jsonNode.get("originalMessageId").asText());
        
        // Special characters and Unicode
        String specialChars = "!@#$%^&*()_+{}|:\"<>?[];',./\\`~\n\t\r\b\f";
        String unicodeChars = "æµ‹è¯• ðŸŽ‰ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© ×¢×‘×¨×™×ª Ñ€ÑƒÑÑÐºÐ¸Ð¹";
        
        DlqMessage specialMessage = DlqMessage.builder()
            .originalMessageId("test")
            .originalMessage(specialChars + unicodeChars)
            .errorMessage(specialChars)
            .errorType("TestException")
            .containerId("test")
            .build();
        
        final String finalSerialized = objectMapper.writeValueAsString(specialMessage);
        jsonNode = objectMapper.readTree(finalSerialized);
        
        // Verify special characters are properly escaped
        assertDoesNotThrow(() -> objectMapper.readTree(finalSerialized));
        assertEquals(specialChars + unicodeChars, jsonNode.get("originalMessage").asText());
        
        // Large content
        String largeContent = "x".repeat(10000);
        DlqMessage largeMessage = DlqMessage.builder()
            .originalMessageId("test")
            .originalMessage(largeContent)
            .errorMessage("error")
            .errorType("TestException")
            .containerId("test")
            .build();
        
        serialized = objectMapper.writeValueAsString(largeMessage);
        jsonNode = objectMapper.readTree(serialized);
        assertEquals(largeContent, jsonNode.get("originalMessage").asText());
    }
    
    @Test
    @DisplayName("Container state enum should validate transitions correctly")
    void testContainerStateValidation() {
        // Test valid transitions
        assertTrue(ContainerState.CREATED.canTransitionTo(ContainerState.STARTING));
        assertTrue(ContainerState.STARTING.canTransitionTo(ContainerState.RUNNING));
        assertTrue(ContainerState.RUNNING.canTransitionTo(ContainerState.STOPPING));
        assertTrue(ContainerState.STOPPING.canTransitionTo(ContainerState.STOPPED));
        
        // Test invalid transitions
        assertFalse(ContainerState.RUNNING.canTransitionTo(ContainerState.CREATED));
        assertFalse(ContainerState.STOPPED.canTransitionTo(ContainerState.RUNNING));
        assertFalse(ContainerState.STARTING.canTransitionTo(ContainerState.CREATED));
        
        // Test failure transitions (should be allowed from any state)
        for (ContainerState state : ContainerState.values()) {
            if (state != ContainerState.FAILED) {
                assertTrue(state.canTransitionTo(ContainerState.FAILED),
                    "Should be able to transition to FAILED from " + state);
            }
        }
        
        // Test recovery from failed state
        assertTrue(ContainerState.FAILED.canTransitionTo(ContainerState.STARTING));
        assertFalse(ContainerState.FAILED.canTransitionTo(ContainerState.RUNNING));
    }
    
    private SqsListenerContainer createTestContainer() throws Exception {
        Object testBean = new Object();
        Method testMethod = testBean.getClass().getMethod("toString");
        
        SqsListener mockAnnotation = mock(SqsListener.class);
        when(mockAnnotation.queueName()).thenReturn("test-queue");
        when(mockAnnotation.queueUrl()).thenReturn("");
        when(mockAnnotation.maxMessagesPerPoll()).thenReturn(10);
        when(mockAnnotation.pollTimeoutSeconds()).thenReturn(20);
        when(mockAnnotation.batchMode()).thenReturn(false);
        when(mockAnnotation.autoDelete()).thenReturn(true);
        when(mockAnnotation.maxRetryAttempts()).thenReturn(3);
        when(mockAnnotation.retryDelayMillis()).thenReturn(1000L);
        when(mockAnnotation.enableDeadLetterQueue()).thenReturn(false);
        when(mockAnnotation.deadLetterQueueName()).thenReturn("");
        
        return new SqsListenerContainer(
            "test-container",
            testBean,
            testMethod,
            mockAnnotation,
            mockSqsService,
            mockEnvironment,
            mockApplicationContext,
            executorService,
            executorService
        );
    }
}